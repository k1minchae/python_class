<aside>
💡 

**학습 목표**

- 논리적 사고력 향상
- 문제 해결 능력 향상
→ 최종 목표는 연습 문제가 아닌 **현실 세계 문제**

학습환경

→**파이참 : 디버그 모드 활용**
→ file → settings → key map 에서 vscode keymap 다운받기

이것이 코딩테스트다 << 책 추천

</aside>

---

# 개요

### 1. 알고리즘

문제를 해결하기 위한 절차나 방법

→방법 : 의사코드(언어의 방식), 순서도

**좋은 알고리즘이란?**

- 정확성
- 작업량
- 메모리 사용량
- 단순성 (우선순위가 낮다.)
- 최적성

### 2. 시간 복잡도

***→ 알고리즘의 작업량을 표현하는 방법***

- 실제 걸리는 시간 측정
- 실행되는 명령문의 개수를 계산

---

# 배열

### 1. 배열이란 무엇인가 ?

- 일정한 자료형의 변수들을 하나의 이름으로 열거하여 사용하는 자료구조
- 여러개의 변수를 사용해야 하는 경우, 이를 배열로 바꾸어 사용
    
    ```python
    num0 = 0
    num1 = 1
    num2 = 2
    
    # 배열 활용
    num = [0, 1, 2]
    ```
    

### 2. 1차원 배열

1. **선언**
    - 별도의 선언 방법이 없으면 변수에 처음 값을 할당할 때 생성
    - 이름 : 프로그램에서 사용할 배열의 이름
        
        ```python
        Arr = list()
        Arr = []
        Arr = [1, 2, 3]
        Arr = [0] * 10    # 1차원에서만 사용 가능 
        # 출력 : [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        print(*Arr)
        # 출력 : 0 0 0 0 0 0 0 0 0 0
        ```
        
2. **접근**
    
    ```python
    Arr[0] = 10 # Arr 배열의 0번 원소에 10 저장
    Arr[idx] = 20 # Arr 배열의 idx번 원소에 20 저장
    ```
    

### 배열 활용 예제 : Gravity

- 상자들이 쌓여있는 방이 있다. 방이 오른쪽으로 90도 회전하여 상자들이 중력의 영향을 받아 낙하한다고 할 때, 낙차가 가장 큰 상자를 구하여 그 낙차를 리턴하는 프로그램을 작성하시오.
- 중력은 회전이 완료된 후 적용된다.
- 상자들은 모두 한 쪽 벽면에 붙여진 상태로 쌓여 2차원의 형태를 이루며 벽에서 떨어져서 쌓인 상자는 없다.
- 상자의 가로 세로 길이는 각각 1이다.
- 방의 가로길이와 세로 길이는 각각 100이다.
- 즉, 상자는 최소 0 최대 100의 높이로 쌓을 수 있다.
- 상자가 놓인 가로 칸의 수 N, 다음줄에 각 칸의 상자 높이가 주어진다.
    
    ```python
    '''입력 예시
    9
    7 4 2 0 0 6 0 7 0
    
    결과 : 7
    '''
    
    def gravity(boxes):
        max_v = 0
        for idx, box in enumerate(boxes): # 인덱스와 요소를 저장하는 함수
            count = 0
            for next in range(idx + 1, N): # N은 가로 길이
                if box > boxes[next]:
                    count += 1
            max_v = max(max_v, count)
        return max_v
    
    T = int(input())  # 테스트 케이스의 개수
    for tc in range(1, T+1):
        N = int(input())  # 방의 가로 길이
        boxes = list(map(int, input().split()))
        result = gravity(boxes) # 디버깅 할 때는 함수 호출하는데에서 중단점 잡기
        print(f'#{tc} {result}')
    ```
    

---

# 정렬

### 1. 정렬의 종류

1. 버블 정렬 - 1일차
2. 카운팅 정렬 - 2일차
3. 선택 정렬
4. 퀵 정렬
5. 삽입 정렬
6. 병합 정렬

### 1. 버블 정렬

인접한 두 개의 원소를 비교하며 자리를 계속 교환하는 방식

**[정렬 과정]**

- 첫 번째 원소부터 인접한 원소끼리 계속 자리를 교환하면서 맨 마지막 자리까지 이동한다.
- 한 단계가 끝나면 가장 큰 원소가 가장 마지막 자리로 정렬된다
- 교환하며 자리를 이동하는 모습이 물 위에 올라오는 거품 모양과 같다고 하여 버블정렬 이라고 한다.
    
    ```python
    # 버블정렬
    list = [55, 7, 89, 12, 42]
    
    for i in range(len(list)):
        for j in range(len(list)-1):
            if list[j] > list[j+1]:
                list[j], list[j+1] = list[j+1], list[j]
    print(list) # [7, 12, 42, 55, 89]
    
    ----
    #강사님 코드
    -> 뒤에서 부터 하는게 더 작업량이 낮아서 좋은 코드임
    for i in range(N-1, 0, -1): # for i : N-1 부터 1까지 순회 
        for j in range(i):  # 비교할 두 원소중 왼쪽의 인덱스
            if arr[j] > arr[j+1]: # 오름차순은 큰수를 오른쪽으로 / 내림차순은 부등호반대
                arr[j], arr[j+1] = arr[j+1], arr[j]
    print(arr) # [1, 2, 3, 4, 5, 7]
    ```
    
    ```python
    # 버블정렬 예시
    numbers = [63, 31, 27, 11, 25]
    
    def bubble(arr):
        # 첫번째 for 문: 배열의 모든 요소 순회
        for i in range(len(arr)):
            # 두번째 for문 : 배열의 끝에서 정렬된 부분 제외후 순회
            for j in range(len(arr) -i -1):
                # 인접한 두 요소를 비교하여 위치 바꾸기
                if arr[j] > arr[j+1]:
                    arr[j], arr[j+1] = arr[j+1], arr[j]
        print(arr)
    
    bubble(numbers) # [11, 25, 27, 31, 63]
    ```
    

### 2. 카운팅 정렬

각 항목들의 순서를 결정하기 위해 ***집합에 각 항목이 몇 개씩 있는지*** 세는 작업을 하여, 선형 시간에 정렬하는 효율적인 알고리즘

**[제한 사항]**

- 정수나 정수로 표현할 수 있는 자료에 대해서만 적용 가능 : 각 항목의 발생 회수를 기록하기 위해, 정수 항목으로 인덱스 되는 카운트들의 배열을 사용하기 때문
- 카운트를 위한 충분한 공간을 할당하려면 집합 내의 가장 큰 정수를 알아야 함
- n이 비교적 작을 때만 가능하다.

**[카운팅 정렬 과정]**

**1단계**

- 데이터에서 각 항목들의 발생 회수를 세고, **정수 항목들**로 직접 인덱스 되는 카운트 배열 counts 에 저장한다.
    
    ```python
    # [0, 4, 1, 3, 1, 2, 4, 1]을 카운팅 정렬하는 과정
    # 0 ~ 4 정수로 구성
    # N 개라면 ? counts = [0] * N 
    # 인덱스가 N이라면 ? counts = [0] * (N + 1)
    data = [0, 4, 1, 3, 1, 2, 4, 1] # 0부터 4까지의 정수
    counts = [0] * 5
    for x in data:
        counts[x] += 1
        # 누적된 개수 구하기 : count[x] += counts[x-1]
        # 적어도 누적된 개수를 구한 그 인덱스 -1 에는 해당 숫자가 있음
    print(counts)    # [1, 3, 1, 1, 2]
    ```
    

**2단계**

- 누적합 구하기

**3단계**  

- 원본데이터에서 오른쪽부터 counts정보를 통해 temp 에 업데이트
- counts[1] 을 감소시키고 원본 데이터와 같은 길이의 temp에 1 삽입
- 같은 값인 경우 원본의 순서를 유지한 채로 정렬한다.
- 정수가 아닐 때 중요함

**[실습]**

```python
N = 6
K = 9 # 0 ~ K
data = [7, 2, 4, 5, 2, 3,] # 0~9 , K = 9
counts = [0] * (K+1)

# 1단계 : counts 배열에 기록하기
for x in data:
    counts[x] += 1
    
# 2단계 : 누적합 구하기
for i in range(1, K+1):
    counts[i] += counts[i-1]

# data의 마지막 원소부터 temp 에 정렬하기
temp = [0] * N # 정렬된 결과 저장
for i in range(N-1, -1, -1): # N-1부터 0번 인덱스 (거꾸로)
    counts[data[i]] -= 1 # 개수를 인덱스로 변환 (남은 개수 계산)
    temp[counts[data[i]]] = data[i]

print(*temp) # 2 2 3 4 5 7
```

***→ N-1 부터 거꾸로 순회하는 이유는?***

: 같은 숫자일 때 원본 순서를 해치지 않기 위해서

```python
# 카운팅 정렬 예시

list = [1, 4, 1, 2, 7, 5, 2]

def counting(arr):
    # 배열의 최댓값
    max_v = max(arr)
    
    # 각 숫자의 등장횟수 초기화
    count = [0] * (max_v + 1)
    
    # count에 각 숫자의 등장 횟수를 세어서 저장
    for num in arr:
        count[num] += 1 # [0, 2, 2, 0, 1, 1, 0, 1]
    
    # count를 순회하여 각 숫자에 해당 숫자의 등장 횟수만큼 저장    
    sorted_arr = []
    # enumerate : 인덱스와 요소를 각각 반환하는 메서드
    for idx, count in enumerate(count):
        
        # idx 가 숫자를 의미함 list * 정수 => 정수만큼 반복
        sorted_arr.extend([idx]*count) 
    return sorted_arr

print(counting(list)) # [1, 1, 2, 2, 4, 5, 7]
```

### Baby-gin Game

- 0~9사이의 숫자 카드에서 임의의 카드 6장을 뽑았을 때, 3장의 카드가 연속적인 번호를 갖는 경우 run 이라고 하고 3장의 카드가 동일한 번호를 갖는 경우를 triplet이라고 한다.
- 그리고, 6장의 카드가 run과 triplet으로만 구성된 경우를 baby-gin이라 한다.
- 6자리의 숫자를 입력받아 baby-gin 여부를 판단하는 프로그램을 작성하라.
- 입력 예 : 667767 (666, 777) → O // 101123 → X

### 순열

주어진 항목들로 만들 수 있는 모든 가능한 순서 (경우의 수)

- itertools 모듈 사용

```python
# itertools 모듈 사용
import itertools
arr = [1, 2, 3]
# 모든 가능한 형태가 튜플 형태로 나옴
result = list(itertools.permutations(arr))
print(result)
# 출력 : [(1, 2, 3), (1, 3, 2), (2, 1, 3), (2, 3, 1), (3, 1, 2), 
#        (3, 2, 1)]
```

### 완전검색

- 완전 검색은 문제의 해법으로 생각할 수 있는 **모든 경우의 수를 나열해보고 확인하는 기법**
- Brute-force 또는 generate-and-test 기법이라고 부른다.
- 모든 경우의 수를 테스트한 뒤 최종 해법 도출
- 경우의 수가 상대적으로 작을 때 유용함 (수행 속도가 느리다)
- 문제를 풀 때 완전 검색으로 답을 구하고 성능 개선을 위해 다른 알고리즘을 사용해서 해답을 확인하는 방법이 바람직 하다.
- **A형의 목표 : 완전검색으로 정확한 답 구하기**
- 단, 불필요한 반복 검색 → **시간초과**

### 탐욕(Greedy) 알고리즘 ↔ 완전검색

- 최적해를 구하는데 사용되는 근시안적인 방법
- 하나를 결정할 때마다 **그 순간에 최적이라고 생각되는것** 선택
- 각 단계에서 가장 최적의 선택을 한다.
- 각 단계에선 최적이지만 이를 종합했을 때 최적이라는 보장은 X
- 일반적으로 머릿속에 떠오르는 생각을 검증 없이 구현하면 Greedy
- **[예시]**
    - 거스름돈 줄이기
    - 어떻게 하면 거스름돈의 지폐와 동전의 개수를 최소한으로?
    - 단위가 큰 돈으로만 거스름 돈을 고른다
        
        ```python
        # 동전의 종류가 100, 50, 10원, 거스름돈이 380원이라면?
        # 동전의 단위와 개수를 출력하는 함수 만들기
        
        # 내가 짠 코드
        def coin(num):
            coin_dict = {}
            coins = ['100', '50', '10']
            for coin in coins:
                coin_dict[coin] = num // int(coin)
                num -= num // int(coin) * int(coin)
            return coin_dict
        
        print(coin(380))
        # 출력 : {'100': 3, '50': 1, '10': 3}
        
        ------------------------------------------------------
        
        # 강사님 코드
        def greedy(money, coins): 
        # money : 거스름돈, coins : 동전단위
        
            coins.sort(reverse = True)
        
            # 각 동전의 개수를 0으로 초기화
            change = {coin: 0 for coin in coins} 
            # {100: 0, 50: 0, 10: 0}
            
            for coin in coins:
        
                # 거슬러 줄 수 있을 동안 반복
                while money >= coin:
                    money -= coin
                    # 거슬러 주는 동안 거스름돈에서 차감
        
                    change[coin] += 1 
                    # 해당 동전의 value 개수를 1씩 증가
        
            return change
        result = greedy(380, [10, 50, 100])
        print(result) # {100: 3, 50: 1, 10: 3}
        ```
        

### ADV

- 완전 탐색을 기반으로 어느 상황에서든 에러없이 돌아가는 프로그램 작성
- BFS : 너비우선 탐색 : 최대한 적은 노드를 돌려서 가는 경로 → 퍼져나가는 형태 구현시
- DFS : 모든 경로로 돌려보는게 가능 → 모든 경우의 수 확인