# 2차원 배열

### 2차원 배열의 선언

- 1차원 리스트를 묶어둔 리스트
- 2차원 이상의 다차원 list는 차원에 따라 인덱스 선언
- **2차원 리스트의 선언 : 세로길이(행의개수), 가로길이(열의개수) 필요**
- 파이썬에서는 데이터 초기화를 통해 변수 선언과 초기화 가능

```python
N = int(input())
arr = [list(map(int, input().split())) for _ in range(N)]
3
1 2 3
4 5 6
7 8 9

N = int(input())
arr = [list(map(int, input())) for _ in range(N)]
3
123
456
789

arr2 = [[0] * N for _ in range(N)] # 이런거 안 됨
arr3 = [[0]* N] * N # 이것도 안 됨
```

### 배열 순회

```python
# i = 행의 좌표
# j = 열의 좌표

# 행 우선 순회
for i in range(n):
    for j in range(m):
        arr[i][j] # 필요한 연산 수행

# 열 우선 순회
for j in range(m):
    for i in range(n):
        arr[i][j] # 필요한 연산 수행

# 지그재그 순회

# 열 : 4, 행 : 3
arr = [[0 for _ in range(4)] for _ in range(3)]
for i in range(3):  # 행 우선 순회
    for j in range(4):
        arr[i][j] # 홀수행 : 순방향 / 짝수행 : 역방향
        arr[i][m-1 에서 j 를 빼면 거꾸로 순회 가능] 
        # 홀수행에서도 j 가 필요하기 때문에 j + (m-1 - 2 * j)
        # 단, 홀수행에서는 (m-1 -2 * j) 이게 필요없으므로 
				#     * (i % 2)를 해준다.
        # 짝수행에서 역방향으로 하고싶으면 (i + 1) % 2
```

### 델타를 이용한 2차 배열 탐색

- 2차 배열의 한 좌표에서 4방향 (인접 배열) 탐색


```python
# i : 세로 / j : 가로
di = [1, -1, 0, 0] # 상 하 좌 우
dj = [0, 0, -1, 1]

# 5 * 5 평면
N = 5
for i in range(N):
    for j in range(N):
        for k in range(4):
            ni = i + di[k]
            nj = j + dj[k]

		# 문제점 : 필드를 벗어나는 것 발생
		# 범위 설정 필요!! if 0 <= ni <N and 0 <= nj < N:
						if 0 <= ni <N and 0 <= nj < N:
	            print((ni, nj), end = ' ')
        print()

arr = [[0 for _ in range(N)] for _ in range(N)]

''' 출력 : 좌표 (세로,가로) 기준 상하좌우
범위설정을 안하면 음수 인덱스도 나옴
(1, 0) (-1, 0) (0, -1) (0, 1) -> (0,0) 기준 
(1, 1) (-1, 1) (0, 0) (0, 2)  -> (0,1) 기준 
(1, 2) (-1, 2) (0, 1) (0, 3)  -> (0,2) 기준 
(1, 3) (-1, 3) (0, 2) (0, 4)  -> (0,3) 기준 
(1, 4) (-1, 4) (0, 3) (0, 5)  -> (0,4) 기준
(2, 0) (0, 0) (1, -1) (1, 1)  -> (1,0) 기준
(2, 1) (0, 1) (1, 0) (1, 2)
(2, 2) (0, 2) (1, 1) (1, 3)
(2, 3) (0, 3) (1, 2) (1, 4)
(2, 4) (0, 4) (1, 3) (1, 5)
(3, 0) (1, 0) (2, -1) (2, 1)  -> (2,0)
(3, 1) (1, 1) (2, 0) (2, 2)
(3, 2) (1, 2) (2, 1) (2, 3)
(3, 3) (1, 3) (2, 2) (2, 4)
(3, 4) (1, 4) (2, 3) (2, 5)
(4, 0) (2, 0) (3, -1) (3, 1)  -> (3,0)
(4, 1) (2, 1) (3, 0) (3, 2)
(4, 2) (2, 2) (3, 1) (3, 3)
(4, 3) (2, 3) (3, 2) (3, 4)
(4, 4) (2, 4) (3, 3) (3, 5)
(5, 0) (3, 0) (4, -1) (4, 1)  -> (4,0)
(5, 1) (3, 1) (4, 0) (4, 2)
(5, 2) (3, 2) (4, 1) (4, 3)
(5, 3) (3, 3) (4, 2) (4, 4)
(5, 4) (3, 4) (4, 3) (4, 5)
'''

''' 범위 설정 한 뒤 정상출력값
(1, 0) (0, 1) 
(1, 1) (0, 0) (0, 2) 
(1, 2) (0, 1) (0, 3) 
(1, 3) (0, 2) (0, 4) 
(1, 4) (0, 3) 
(2, 0) (0, 0) (1, 1) 
(2, 1) (0, 1) (1, 0) (1, 2) 
(2, 2) (0, 2) (1, 1) (1, 3) 
(2, 3) (0, 3) (1, 2) (1, 4) 
(2, 4) (0, 4) (1, 3) 
(3, 0) (1, 0) (2, 1) 
(3, 1) (1, 1) (2, 0) (2, 2) 
(3, 2) (1, 2) (2, 1) (2, 3) 
(3, 3) (1, 3) (2, 2) (2, 4) 
(3, 4) (1, 4) (2, 3) 
(4, 0) (2, 0) (3, 1) 
(4, 1) (2, 1) (3, 0) (3, 2) 
(4, 2) (2, 2) (3, 1) (3, 3) 
(4, 3) (2, 3) (3, 2) (3, 4) 
(4, 4) (2, 4) (3, 3) 
(3, 0) (4, 1) 
(3, 1) (4, 0) (4, 2) 
(3, 2) (4, 1) (4, 3) 
(3, 3) (4, 2) (4, 4) 
(3, 4) (4, 3)
'''

# 델타값 만드는 또다른 방법
for i in range(N):
    for j in range(N):
        for di, dj in [[0,1], [1,0], [0,-1], [-1,0]]:
            ni, nj = i+di, j+dj
```

### 전치 행렬

- 행렬의 (0,0) (1,1) (2,2) :  **대각선 코드 활용**
    
    ```python
    # i : 세로 / j : 가로
    arr = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
    
    for i in range(3):
        for i in range(3):
            arr[i][i] # 행렬의 대각선 영역
    
    # 대각선을 기준으로 오른쪽 위 : i < j
    # 대각선을 기준으로 왼쪽 아래 : i > j
    
    # 대각선을 기준으로 맞바꾸는 코드
    arr = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
    for i in range(3):
        for i in range(3):
    
         # 이 조건이 없으면 양쪽에서 다바꿔서 원래 행렬로 돌아옴
            if i < j: 
                arr[i][j], arr[j][i] = arr[j][i], arr[i][j]
    ```
    

### 연습문제

5x5 2차 배열에 25개의 숫자를 저장하고, 대각선 원소의 합을 구하시오.

---

## 부분집합의 합 문제

- 유한개의 정수로 이루어진 집합
- 그 집합의 부분집합 중에서 그 집합의 원소를 모두 더한 값이 0이 있는지?
- 예를 들어, [-7, -5, -2, 5, 8] 집합에서 [-3, -2, 5]는 조건을 충족함

**→ 완전 검색 기법으로 문제풀기**

- 모든 부분집합 생성
- 각 부분집합의 합 계산

**→ 부분집합의 수**

- 집합의 원소가 n 개일 때 공집합을 포함한 부분집합의 수는 2 ** n 개
- 각 원소는 독립적으로 부분집합에 (포함 or 포함X) 이라는 두가지 경우의 수를 가짐
- {1, 2, 3, 4} → 2 x 2 x 2 x 2 = 16

### 비트 연산자

***비트 : 0과 1로 상태를 구분할 수 있는 최소 단위***

- ‘&’ : 비트 단위로 AND 연산 → *둘다 1일 때만 1이 되는*
- ‘|’ : 비트 단위로 OR 연산 → *하나라도 1이 되면 1이 되는*
- ‘<<’ : 피연산자의 비트 열을 왼쪽으로 이동시킴
- ‘>>’ : 피연산자의 비트 열을 오른쪽으로 이동시킴
- << 연산자
    
    → 1 << n : 원소가 n 개일 경우의 모든 부분집합의 수를 의미
    
    = 2**n
    
- & 연산자
    
    → i & (1<<j) : i의 j번째의 비트가 1인지 아닌지를 검사
    

```python
arr = [3, 6, 7, 1, 5, 4]

n = len(arr)

for i in range(1<<n): # 1<<n : 부분 집합의 개수 (2**n -1까지)
    for j in range(n):  # 원소의 수만큼 비트 비교
        if i & (1<<j):  # i의 j번 비트가 1인 경우
            print(arr[j], end=",")  # j번 원소 출력
    print()
print()
```



```python
N = 3
arr = [1, 2, 3]

for i in range(1<<N):  # i 가 b0, b1, b2를 가지도록
                    # i 값이 0 0 0  ~ 1 1 1  까지
    for j in range(N):
        if i & (1<<j):
            print(arr[j], end = ' ')

    print()

'''
모든 부분집합
1
2
1 2
3
1 3
2 3
1 2 3
'''
```

```python
# 모듈로 하는법
import itertools

lst = [1, 2, 3]

# lst의 순열
result1 = list(itertools.combinations(lst, 3))
# combinations(lst, N) : lst 에서 N개의 원소를 가진 모든 조합 (중복X)

result2 = list(itertools.combinations(lst, 2))
print(result2)
```

---

## 검색

### 검색의 종류

- 순차 검색
- 이진 검색

### 1. 순차 검색

**일렬로 되어 있는 자료를 순서대로 검색하는 방법**

- 가장 간단하고 직관적임
- 배열, 연결 리스트 등 순차구조로 구현된 자료구조에서 유용
- 단순해서 구현이 쉽지만 수가 많을 경우엔 수행시간 급증 → ***비효율***
- 정렬 되어있지 않은 경우와 정렬된 경우로 나뉨

**[검색 과정]**

- 첫 번째 원소부터 순서대로 검색해서 찾는다.
- 키 값이 동일한 원소를 찾으면 해당 원소의인덱스 반환
- 마지막에 이를 때까지 검색 대상을 못찾으면 실패
- 정렬되어있지 않으면 찾고자하는 원소의 순서에 따라 비교 회수가 결정됨

### 2. 이진 검색

- 자료의 가운데에 있는 항목의 키 값과 비교하여 다음 검색의 위치를 검색하고 검색을 계속 진행하는 방법
    
    → 찾을 때까지 이진검색을 순환적으로 반복 수행해서 검색 범위를 반으로 줄여가며 빠르게 검색한다.
    
- **이진 탐색을 하기 위해서는 자료가 정렬되어 있어야 함**

**[검색 과정]**

- 자료의 중앙에 있는 원소 고름
- 중앙 원소의 값과 찾고자 하는 목표값 비교
- 목표값이 중앙 값보다 작으면 왼쪽 자료만 새로 검색
    
    (크다면 오른쪽 자료만)
    
- 찾고자 하는 값을 찾을 때까지 과정 반복

```python
def binarySearch(arr, N, key):
    start = 0   # 구간 초기화
    end = N-1

    # 검색 구간이 유효하면 반복
    while start <= end:
        # 중앙원소의 인덱스
        middle = (start + end) // 2
        if arr[middle] == key: # 검색 성공
            return middle
        # 중앙값이 키보다 크면
        elif arr[middle] > key:
            end = middle # 끝값 변경
        else: # 중앙값이 키보다 작으면
            start = middle # 시작값 변경

    return False # while 문바깥으로 빠져나오면 검색실패
```

### 인덱스

- 용어는 Database 에서 유래
- 테이블 동작속도를 높여주는 자료구조
- 인덱스를 저장하는데 필요한 디스크 공간은 테이블 저장하는데 필요한 공간보다 작다.
- 보통 인덱스는 키-필드만 갖고있고 세부 항목은 안가지고 있으므로.
- 배열을 사용한 인덱스 : 대량의 데이터를 매번 정렬하면 느려짐 → 배열 인덱스 사용
- 원본데이터에 데이터가 삽입될 경우 상대적으로 크기가 작은 인덱스 배열을 정렬하기 때문에 속도가 빠르다.

### 선택 정렬

- 주어진 자료들 중 가장 작은 값의 원소부터 차례대로 선택하여 위치 교환 → 앞서 살펴본 셀렉션 알고리즘을 전체 자료에 적용한 것
- 교환의 회수가 버블, 삽입정렬보다 작다
- 정렬과정
    - 주어진 리스트에서 최소값의 위치 찾기
    - 그 값을 리스트의 맨 앞과 교환
    - 나머지 리스트를 대상으로 위의 과정 반복

```python
def selectionSort(arr, N):
    for i in range(N-1):

    # 주어진 구간의 시작 (맨 앞 위치를 최소값이라 가정)
        min_idx = i 

        for j in range(i+1, N): # 구간안에서

        # 실제 더 작은 값을 찾았다면?
            if arr[min_idx] > arr[j]: 
                min_idx = j # 최소값 업데이트
        arr[i], arr[min_idx] = arr[min_idx], arr[i]
```

### 셀렉션 알고리즘

- 저장되어 있는 자료로부터 k번째로 크거나 작은 원소를 찾는 방법
- 최소값 or 최대값을 찾는 알고리즘
- 과정 : 정렬 → 원하는 순서의 원소 가져오기
- 예시 : k 번째로 작은 원소를 찾으려면?
    
    → 1~k번째까지 정렬하고 k번째 반환
    

```python
def selectionSort(arr, N):
# 구간시작 : 1 , 2개의 원소가 남을 때까지
    for i in range(N-1): 
        min_idx = i # 최소값의 위치
        for j in range(i+1, N): # 실제 최소값을 찾을 위치 j
            # 실제 더 작은 값을 찾았다면?
            if arr[min_idx] > arr[j]: 
                min_idx = j # 최소값의 인덱스 업데이트
        # 최솟값을 구간의 맨 앞으로 이동
        arr[i], arr[min_idx] = arr[min_idx], arr[i] 

    return

N = 5
arr = [1, 3, 2, 5, 4]
print(arr)  # [1, 3, 2, 5, 4] 정렬 전
selectionSort(arr, N)
print(arr)  # [1, 2, 3, 4, 5] 정렬 후
```

→ SWEA 1954. 달팽이 숫자 << 연습문제로 활용하기