<aside>
💡 **학습목표**
- 논리적 사고력 향상
- 문제 해결 능력 향상
→ 최종 목표는 연습 문제가 아닌 **“현실 세계 문제”

학습환경
→\*\* 파이참 : 디버그 모드 활용
→ file → settings → key map 에서 vscode keymap 다운받기

이것이 코딩테스트다 << 책 추천

</aside>

---

# 개요

### 1. 알고리즘

문제를 해결하기 위한 절차나 방법

→방법 : 의사코드(언어의 방식), 순서도

**좋은 알고리즘이란?**

- 정확성
- 작업량
- 메모리 사용량
- 단순성 (우선순위가 낮다.)
- 최적성

### 2. 시간 복잡도

**_→ 알고리즘의 작업량을 표현하는 방법_**

- 실제 걸리는 시간 측정
- 실행되는 명령문의 개수를 계산

---

# 배열

### 1. 배열이란 무엇인가 ?

- 일정한 자료형의 변수들을 하나의 이름으로 열거하여 사용하는 자료구조
- 여러개의 변수를 사용해야 하는 경우, 이를 배열로 바꾸어 사용
  ```python
  num0 = 0
  num1 = 1
  num2 = 2

  # 배열 활용
  num = [0, 1, 2]
  ```

### 2. 1차원 배열

1. **선언**
   - 별도의 선언 방법이 없으면 변수에 처음 값을 할당할 때 생성
   - 이름 : 프로그램에서 사용할 배열의 이름
     ```python
     Arr = list()
     Arr = []
     Arr = [1, 2, 3]
     Arr = [0] * 10    # 1차원에서만 사용 가능
     # 출력 : [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
     print(*Arr)
     # 출력 : 0 0 0 0 0 0 0 0 0 0
     ```
2. **접근**

   ```python
   Arr[0] = 10 # Arr 배열의 0번 원소에 10 저장
   Arr[idx] = 20 # Arr 배열의 idx번 원소에 20 저장
   ```

### 배열 활용 예제 : Gravity

- 상자들이 쌓여있는 방이 있다. 방이 오른쪽으로 90도 회전하여 상자들이 중력의 영향을 받아 낙하한다고 할 때, 낙차가 가장 큰 상자를 구하여 그 낙차를 리턴하는 프로그램을 작성하시오.
- 중력은 회전이 완료된 후 적용된다.
- 상자들은 모두 한 쪽 벽면에 붙여진 상태로 쌓여 2차원의 형태를 이루며 벽에서 떨어져서 쌓인 상자는 없다.
- 상자의 가로 세로 길이는 각각 1이다.
- 방의 가로길이와 세로 길이는 각각 100이다.
- 즉, 상자는 최소 0 최대 100의 높이로 쌓을 수 있다.
- 상자가 놓인 가로 칸의 수 N, 다음줄에 각 칸의 상자 높이가 주어진다.
  ```python
  '''입력 예시
  9
  7 4 2 0 0 6 0 7 0

  결과 : 7
  '''

  def gravity(boxes):
      max_v = 0
      for idx, box in enumerate(boxes): # 인덱스와 요소를 저장하는 함수
          count = 0
          for next in range(idx + 1, N): # N은 가로 길이
              if box > boxes[next]:
                  count += 1
          max_v = max(max_v, count)
      return max_v

  T = int(input())  # 테스트 케이스의 개수
  for tc in range(1, T+1):
      N = int(input())  # 방의 가로 길이
      boxes = list(map(int, input().split()))
      result = gravity(boxes) # 디버깅 할 때는 함수 호출하는데에서 중단점 잡기
      print(f'#{tc} {result}')
  ```

---

# 정렬

### 1. 정렬의 종류

1. 버블 정렬 - 1일차
2. 카운팅 정렬
3. 선택 정렬
4. 퀵 정렬
5. 삽입 정렬
6. 병합 정렬

### 1. 버블 정렬

인접한 두 개의 원소를 비교하며 자리를 계속 교환하는 방식

[**정렬 과정]\*\*

- 첫 번째 원소부터 인접한 원소끼리 계속 자리를 교환하면서 맨 마지막 자리까지 이동한다.
- 한 단계가 끝나면 가장 큰 원소가 가장 마지막 자리로 정렬된다
- 교환하며 자리를 이동하는 모습이 물 위에 올라오는 거품 모양과 같다고 하여 버블정렬 이라고 한다.
  ```python
  # 버블정렬
  list = [55, 7, 89, 12, 42]

  for i in range(len(list)):
      for j in range(len(list)-1):
          if list[j] > list[j+1]:
              list[j], list[j+1] = list[j+1], list[j]
  print(list) # [7, 12, 42, 55, 89]

  ----
  #강사님 코드
  -> 이게 더 작업량이 낮아서 좋은 코드임
  for i in range(N-1, 0, -1): # for i : N-1 -> 1
      for j in range(i):  # 비교할 두 원소중 왼쪽의 인덱스
          if arr[j] > arr[j+1]: # 오름차순은 큰수를 오른쪽으로 / 내림차순은 부등호반대
              arr[j], arr[j+1] = arr[j+1], arr[j]
  print(arr) # [1, 2, 3, 4, 5, 7]
  ```

### 2. 카운팅 정렬

각 항목들의 순서를 결정하기 위해 **_집합에 각 항목이 몇 개씩 있는지_** 세는 작업을 하여, 선형 시간에 정렬하는 효율적인 알고리즘

**[제한 사항]**

- 정수나 정수로 표현할 수 있는 자료에 대해서만 적용 가능 : 각 항목의 발생 회수를 기록하기 위해, 정수 항목으로 인덱스 되는 카운트들의 배열을 사용하기 때문
- 카운트를 위한 충분한 공간을 할당하려면 집합 내의 가장 큰 정수를 알아야 함

**[카운팅 정렬 과정]**

**1단계**

- 데이터에서 각 항목들의 발생 회수를 세고, **정수 항목들**로 직접 인덱스 되는 카운트 배열 counts 에 저장한다.
  ```python
  # [0, 4, 1, 3, 1, 2, 4, 1]을 카운팅 정렬하는 과정
  # 0 ~ 4 정수로 구성
  # N 개라면 ? counts = [0] * N
  # 인덱스가 N이라면 ? counts = [0] * (N + 1)
  data = [0, 4, 1, 3, 1, 2, 4, 1] # 0부터 4까지의 정수
  counts = [0] * 5
  for x in data:
      counts[x] += 1
      # 누적된 개수 구하기 : count[x] += counts[x-1]
  print(counts)    # [1, 3, 1, 1, 2]
  ```
